Link do vídeo: [https://youtu.be/liID0DWCuvE](https://youtu.be/liID0DWCuvE)

Viajando, logo mais volto!
agora resolvendo coisas da unip décimo primeiro dia

00:00
E aí pessoal, tudo bem? Mais um vídeo aqui sobre Gol e a gente vai falar um pouquinho sobre como é possível o compilador em Go ser escrito em Go, tá? Então a gente vai começar a ter assuntos aqui sobre compiladores e garbage collector no canal. E hoje a gente vai começar com esse ponto do como é possível, como funciona o compilador do Gol para que ele seja escrito em Go. Mas como isso é possível, como isso acontece, né? Então a gente vai falar um pouquinho hoje sobre bootstrapping, sobre compilador e sobre como um
00:24
pouquinho ali um overview de como isso tudo funciona. Beleza? Então vamos pro vídeo. [Música] Right anale pulling yourself up your bootstraps. A gente aqui tem um desafio, né? Como compilar o go então com um compilador escrito em GO. Então o Bootstrap no contexto de linguagem e programação, ele é basicamente um processo de construir um compilador pra linguagem usando o compilador existente para essa linguagem ou outra linguagem, tá? Então é basicamente eu criar uma uma linguagem a partir de outra linguagem, só que essa
01:19
linguagem que eu criei saber interpretar ela mesma. Então eu criar meio que um ciclo onde ela é meio que autocontida, eu consigo criar um fluxo onde a linguagem que eu criei ela sabe entender a ela mesma e ela sabe se criar, vamos assim dizer. Então a gente tem aqui o bootstrapping basicamente que é o seguinte: imagina que você pode construir uma máquina que ela monta ela mesma. Ou então é como você escrever um livro que basicamente te ensina a escrever o livro. Então você tá escrevendo um livro que te ensina a
01:46
escrever o próprio livro. Então, alguns paralelos aqui, só para vocês entenderem de como seria mais ou menos a teoria do Bootstrapping numa linguagem de programação, tá? É como se ele soubesse se recriar, é como se ele soubesse como foi criado inicialmente para que ele crie novamente. Parece uma mágica até. Vamos começar aqui do estágio zero. Basicamente, o estágio zero é onde o primeiro compilador da nova linguagem é escrito em uma linguagem de programação diferente. Por isso que a maioria das
02:09
linguagens hoje elas são compiladas em outra linguagem, por exemplo, ou foram criadas a partir de outra linguagem. por exemplo, Java, o próprio Gok foi criado em C. Então, a maioria das linguagens hoje que são criadas são criadas em C ou em C++, tá? E aí são criadas outras linguagens e outras linguagens criam outras linguagens e assim sucessivamente. Mas sempre tem uma linguagem core que começa todo esse esse desenho, todo esse toda essa estrutura de linguagens, tá? Então, geralmente é utilizado o C++ porque são linguagens
02:39
velozes, né? ou cam também, que são linguagens muito velozes, a gente já conhece que o C é muito rápida, então o compilador do C acaba sendo muito efetivo para isso. Essa linguagem pi pode ser chamada de linguagem host ou bootstrap, tá? Que aí vem o termo. Então a linguagem host é a linguagem que vai criar a sua linguagem e aí a sua linguagem tende a saber criar ela mesma no futuro, tá? E aí ela vai ser a linguagem host de uma outra linguagem, beleza? Então bootstrapping basicamente é a segunda etapa, né? Então, a segunda
03:05
e as etapas seguintes do desenvolvimento do compilador são chamados de bootstrapping aqui nesse caso. Então, nessa fase, o compilador é reescrito na linguagem que ela foi projetada para ser escrita. Então, eu escrevi minha linguagem, o compilador C entende a minha linguagem. Eu faço com que a minha linguagem consiga compilar o compilador da minha própria linguagem, tá? Então eu basicamente escrevo o compilador da minha linguagem pro C compilar essa linguagem, esse compilador. Então nessa fase o compilador é reescrito na
03:30
linguagem paraa coletado. Então basicamente eu reescrevo o compilador, ou seja, eu escrevo um código que o C entende. Com esse código eu vou utilizo, eu vou e crio um compilador que o C também entende e faço o meu compilador entender a minha própria linguagem. Então, faço com que o compilador em GO, que é foi criado em C, que foi baseado e interpretado pelo C, saiba entender um código em GO. Assim, ele consegue compilar o código em GO, só que ele foi inicialmente compilado pelo C. Então, mais ou menos essa ideia do
03:58
bootstrapping, tá? Então esse processo ele pode ser repetido até que o compilador se torne totalmente self hosted. Então ele até que ele entenda totalmente a sua própria linguagem. O que significa que ele pode compilar todos os componentes essenciais de uma linguagem de programação funcional aqui nesse caso. Então ele vai entender todas as entradas e saídas. Ele de IO, por exemplo, que ele consegue ter acesso ao terminal, arquivos, ao sistema operacional, sistema de arquivos, iteração com sistema operacional em si e
04:24
tudo que uma linguagem de programação geralmente consegue fazer, que a gente conhece, tá? Então, geralmente esse processo ele é repetido até que ele consiga compilar tudo isso. Então aqui ilustrando, Bootstrapping seria basicamente um primeiro compilador que geralmente ele é escrito em C ou C++ mais+ como eu disse e daí ele vai ser criado um Bootstrapper compiler. Então basicamente vai ser um compilador simples escrito nessa nova linguagem que você vai criar essa ferramenta. Então você escreve uma nova linguagem que o
04:48
primeiro compilador que é o compilador base vai saber compilar ele, tá? Então o compilador self hosted, nesse caso, que é o que eu tô criando, ele é o estágio final de um compilador. Então o objetivo final de todo compilador é chegar nesse estágio, é chegar no momento que ele é self hosted, ele consegue buildar a própria linguagem ou ele consegue criar novas linguagens, tá? Inclusive, eu vou mostrar um exemplo daqui a pouco. Então, nessa fase, o compilador da nova linguagem de programação, ele é
05:12
totalmente autônomo e ele depende pouco do foreign function interface, porque aqui o forign function interface é, no caso, quem criou ele, qual é a interface de criação dele, qual é o host, quem criou ele, ele não tem nenhuma relação com a linguagem de criação dele. Então, geralmente quando você vê no Go, por exemplo, o CO enable de que a gente vai falar um pouquinho mais, ele não tem nenhuma relação. Você pode desativar ou ativar. Então, você não tem ligação nenhuma com a linguagem que te criou,
05:36
vamos assim dizer. você consegue se entender totalmente, tá? Então aqui o Bootstrapping basicamente é o primeiro compilador. O que que vai acontecer agora? Ele vai virar o bootstrapped compiler, só que dele a gente vai criar o self hosted compiler, que é o compilador que entende a própria linguagem. Então ele vai ser uma linguagem totalmente funcional, já que eu consigo compilar ela mesma, tá? E disso a gente vai tirar totalmente. Ou seja, eu tenho um self hosted aqui, ele não tem nenhuma ligação com formace,
06:02
porque quem conhece formace é o Boostrapid Compiler, que foi criado a partir da interface ou da linguagem original, tá? Então por isso que você não tem nenhuma ligação entre as duas pontas. Você geralmente quebra todo tipo de de interação que você tem com a linguagem original, com as interfaces da linguagem original ou algo do tipo, tá? Não é como se eu tivesse utilizando o Go para chamar o C pro Cema operacional. O Go sabe chamar o sistema operacional. A linguagem que eu criei sabe chamar o sistema operacional e assim por diante,
06:31
tá? Então aqui um exemplo um de um bootstrapping simples aqui é você escrever um compilador na linguagem A em A. Então eu quero escrever um compilador em go em de go em go nesse caso, né? Então o problema basicamente é você ainda não tem o compilador da linguagem go ou da linguagem A para compilar o código em GO código A. Tá? Então você não tem um compilador de código A para escrever código A, tá? Então você escreve um compilador A em B. Então aqui é como se eu tivesse escrevendo um compilador go em C, tá? Então uma
07:00
linguagem que já era um compilador, que já tenha um compilador, no caso aqui do C ou do C++. Depois você usa esse compilador que é escrito em B para compilar o próprio compilador que agora foi reescrito em A. Então você reescreve o compilador na linguagem que você quer e usa o compilador original para compilar ele. Então você compila o compilador, basicamente isso, tá? Então vira basicamente essa estrutura aqui pequena de B para A, A para A, tá? Então é mais ou menos essa ideia aqui. Coloquei A a e B para também não ficar
07:28
utilizando só o exemplo do Gol, porque isso é utilizado em muita linguagem e muito compilador. Beleza? Então aí como que vai ficar isso, né? Você basicamente escreve compilador A em B, ou seja, o compilador A para B. E você usa esse compilador A para B para compilar o compilador A para A, ou seja, sem nenhuma relação com fortiner face, tá? Então você vai criar essa interface para que você não precisa mais da linguagem original, da linguagem host aqui nesse caso. Então agora basicamente você vai
07:55
ter um compilador A para que pode se autocompilar ou autohospedagem, self host e assim por diante, tá? Então aqui seria basicamente esse desenho. Então a fase um aqui de compilar inicialmente em C. Então a equipe do GO basicamente desenvolveu inicialmente a linguagem com o compilador do Bootstrap escrito em C, utilizando essa ideia. Então esse compilador de Bstrap, ele foi responsável aqui nesse caso por compilar um subconjunto mínimo do código Gol. Então basicamente o mínimo para entender o código GO. Então na nas versões do Gol
08:23
1.14 para trás você terem totalmente dependência do C. Então o Gol foi sim utilizado com apenas com C, sem o compilador original por muito tempo, até que ele tenha as atualizações e hoje não precise mais dele, tá? Então esse subconjunto de código compilado pela pelo C aqui nesse caso inclui apenas o suficiente para implementar runtime básico ali do GO, como garbage Collector, coisa simples ali para realmente rodar o runtime e entender alguma coisa da linguagem, para realmente você ter uma linguagem
08:51
executável, vamos assim dizer. Então esse basicamente foi o passo crucial aqui para alcançar autossuficiência ou self host assim por diante. Então você tem o C compiler, que ele gera um ele entende um zumbi conjunto de go e depois ele cria um runime de goarbe minimum para você executar essa linguagem, porém ainda sendo compilado pelo C. Beleza? E aí você tem a fase dois que é runtime básico em Gol. Então, com run time do GO e o Gbert Collector implementado aqui, nesse caso, a equipe de GO ali começou a
09:19
escrever um compilador Go no próprio Gol, utilizando ali o Bootstrapping. Então esse novo compilador Go era capaz de compilar um subconjunto mais extenso do código GO, porque aí você cria uma linguagem que entende ela a mesma, então você cria uma infinita possibilidade, tá? Então você não tem mais uma limitação de uma linguagem original, tá? Então isso começou a abrir portas para uma criação maior, porque, por exemplo, você pode escrever uma linguagem de programação e colocar o Go para compilar
09:43
ela. Então tem até, vou deixar o link na descrição, de uma pessoa no Reddit ali que basicamente escreveu uma linguagem que o Go compila ela. Então ele escreveu uma linguagem em GO, beleza? Então você consegue, ele chamou aqui de column e aí você consegue criar linguagem para basicamente fazer a mesma coisa, o mesmo processo. Aí ele pode fazer basicamente um dia que o colon saiba entender column. Meio que é essa ideia aqui do bootstrapping. Beleza? E a fase três, o compilador escrito em go. Então, o
10:08
compilador self hosted, ele foi então usado para compilar uma parte maior da biblioteca padrão e a maior linguagem go, tá? Então, um pouquinho mais a linguagem go até chegar onde a gente conhece hoje. Então, esse processo foi repetido interativamente até que o compilador Go escrito em Gol conseguisse compilar toda a linguagem que é como a gente conhece hoje. Então, como eu falei, desde o go 1.5, o Gol é totalmente compilado em Gol, tá? com 1 1.4 para trás ali você tem a dependência do C ainda. Então isso marcou ali um
10:37
divisor de água porque o C se tornou dispensável no processo de compilação do Gol, porém você consegue ativar e você consegue usar o GO para chamar um código C, por exemplo, você tem aquela variável CGO enabled, que eu vou mostrar já já. E aí você tem um compiler em go jun, ele meio que compila o seu código em go código C. Então você consegue utilizar C dentro do seu código GO. A gente tem vídeo aqui no canal sobre isso, beleza? Mas aqui não é totalmente dependente. Você não precisa do C para buildar um
11:03
código go. Você consegue desativar e ativar essa funcionalidade, mas se você desativar, você vai funcionar o seu código normalmente, tá? Geralmente, inclusive é desativado para gerar docker file, por exemplo. Ele gera um Docker file menor porque ele não precisa do C, então basicamente ele desativa aqui, tá? Então, por que esse método? Por que que ele faz isso, né? Então, simplicidade autocontenção. Então, o Go foi criado para ser minimalista e ele realmente é e fácil de manter. Então, Bootstrap
11:28
reflete essa filosofia porque já que ele entende a ele mesmo, ele fica cada vez mais simples porque ele não tem dependência externa. Então, a portabilidade começou com C para atingir várias várias plataformas, porque o C ele consegue isso e depois ele se tornou independente utilizando só GO. Tanto que hoje você consegue compilar gerar o executável do Gol para qualquer linguagem e você não precisar do Gol instalado na sua máquina para isso, tá? Então fica mais fácil ainda e ficou ainda com uma portabilidade ainda maior
11:54
hoje em dia. Evolução mais ágil com compilador em GO ficou mais fácil evoluir a linguagem e aplicar melhorias. Beleza? Então agora, beleza, a gente falou aí do CGO enabled, mas e essa variável do CGO enabled, né? Basicamente essa variável, para quem não conhece, quando você dá um go env, ela vai te mostrar lá o go enabled. Ela basicamente permite que o go chame biblioteca C. Geralmente essa variável ela vem como valor um, ou seja, ela vem ativa. Então toda vez que você builda um código em GO, ele tem código C dentro para você
12:23
executar código C ou executar algum tipo de comando com o sistema operacional e assim por diante, tá? Então a compilação sem dependência externa, ou seja, CE, que é quando você desativa CCO enabled, então desde o Go 1.5 o compilador é escrito em Go, como eu falei. Então isso possibilita o compilador Go sem precisar do GCC. Então não preciso do Seleng, GCC, TNC, eu não preciso de nada disso porque eu posso simplesmente desativar. Então coloco o CG en boot como zero, ele vai compilar sem o C, beleza? Então você
12:50
não tem mais essa necessidade. Portabilidade total com seg enable de zero, então usado amplamente em cross completion. Então quando eu vou colocar um docker minimalista, como eu falei, se eu quero deixar o meu executável ainda menor, eu desativo o seg, tá? Então ele garante um binário ainda menor, não muita diferença, não é um negócio que você vai ter um ganho exorbitante, mas é uma coisa que não, se não tem necessidade, é melhor desativar, né? Meio que isso. E aí geralmente desativam quando vai gerar docker file
13:18
para que tenha uma imagem ainda menor. Eu vou mostrar isso já já. Beleza? E a filosofia do go em ação. Seg enable zero representa filosofia do go, que é um binário simples, sem muita coisa, autoconto, fácil de compilar e portar, porque ele vai executar em qualquer sistema. E exatamente que o Bootstrapou a viabilizar aqui na linguagem. Beleza? Então na teoria basicamente isso. Eu vou mostrar alguns pontos agora na linguagem. Então aqui por exemplo, eu tenho um código base aqui que tem um mem.g user. Current. Ele vai utilizar uma o
13:47
funcionamento aqui de usar o sistema operacional. Então para poder saber saber o usuário que tá utilizando, ele vai printar com a usuária atual aqui nesse caso. Beleza? Se, por exemplo, eu venho aqui e coloco um CO enabled, então para eu saber o meu valor, então sego underline enabled, vocês vão ver que tá o valor um, que é o valor default, tá? Se eu coloco aqui um CGO underline enabled e coloco igual a um para garantir que vai ser um aqui nesse caso. E aí você coloca um go build o e vou colocar com C go e vou colocar ponto,
14:16
beleza? E vou buildar esse código com valor um e vou buildar esse código com valor zero, beleza? Eu vou colocar sem CO, beleza? E aí agora se eu venho aqui e coloco um LDD aqui, por exemplo, no conc, vocês vão ver que tem aqui o lib, tá vendo? Então aqui lib.sso e etc. Vai tá aqui utilizando. E aí se eu faço a mesma coisa no sense, vocês vão ver que não é na hora dynamic executable, tá? Então você vai ver que ele não consegue trazer as mesmas informações aqui porque você buildou sem o pacote CG, então ele
14:49
não vai ter as mesmas dependências aqui que ele foi gerado, beleza? no executável. Aí aqui a gente, por exemplo, tem um um código aqui funcionando que a gente tem uma lock aqui do C, tá utilizando o pacote C, tá utilizando tudo aqui, tá com CGO. E aí vamos supor que eu venho aqui e coloco um go build men o e vou coloco com c nov.g. E aí a gente vai fazer o seguinte, a gente vai colocar aqui no começo enabled cg underline enabled e eu vou colocar igual a zero, tá? Então, enabled igual a zero. Aqui nesse caso a gente tenta
15:21
buildar. Então, go no search files. Agora, se eu executo com o valor um aqui nesse caso, ele vai conseguir fazer o build, tá vendo? Então aqui entram a utilização de C. Se você quiser utilizar por algum motivo uma linguagem C dentro do GO, a gente tem aqui o funcionamento que precisa dessa variável. Senão ele não consegue buildar, obviamente, né? porque ele não vai ter como interpretar esse código, já que não tem nenhuma ligação entre o Gol e o C nesse cenário de hoje em dia, depois dessas versões
15:47
com o self hosted do Golo. Beleza? Mas vamos supor que eu trouxe um outro código, nada a ver aqui, basicamente que pega interfaces aqui, net. Não utiliza o pacote OS. Aqui nesse caso, eu vou e dou um go build aqui novamente. CG go enable, go build, vou colocar com cmain. Tá? E eu vou executar um outro com valor zero. Vou colocar aqui sem c main.goo, tá? E vou executar a mesma coisa. Se eu venho e coloco um ls men aqui sem ser go e com ser go, a gente vai executar. Vocês vão ver que a diferença é tão
16:18
pequena que às vezes nem mostra aqui, por exemplo, a diferença entre eles, tá? Ele tem uma diferença muito pequena entre os dois pacotes aqui de tamanho de build, então não é uma coisa que vai mudar muito, mas geralmente utilizam no Docker File aqui para poder ah, se eu não preciso, eu não vou utilizar, mas não é uma coisa que vai gerar um build muito menor para você, que faça tanta diferença de você especificar isso, tá? Mas por convenção geralmente coloca no Docker File, então já virou meio que um
16:42
padrão. Beleza? Então essas são as diferenças aqui quando você vê que o Gol não tem mais essa necessidade da linguagem. Beleza? Então espero que vocês tenham gostado do vídeo. Nos vemos no próximo vídeo em Go e até a próxima. Falou.